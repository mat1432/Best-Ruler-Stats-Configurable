# Written by mat1432 (Steam) https://steamcommunity.com/id/mat1432/ or https://github.com/mat1432 (GitHub)

brs_enable_mod = {
	custom_tooltip = brs_enable_mod_tt
	hidden_effect = { clr_country_flag = brs_disabled }
}
brs_disable_mod = {
	custom_tooltip = brs_disable_mod_tt
	hidden_effect = { set_country_flag = brs_disabled }
}
brs_set_minimum = {
	custom_tooltip = brs_set_minimum_tt
	hidden_effect = { set_country_flag = brs_minimum }
}
brs_clr_minimum = {
	custom_tooltip = brs_clr_minimum_tt
	hidden_effect = { clr_country_flag = brs_minimum }
}

# If a mod is updated and the defines for max ruler stats changes. Upon this mod updating the template will adjust the selected value.
# NOTE: This would be an intensive check, it will only ever run when opening a menu!
brs_validate = {
	hidden_effect = {
		# EDIT: Templates
		# checks if variable is negative, or above [1+] the maximum
		if = {
			limit = {
				OR = {
					NOT = {
						check_variable = {
							which = brs_template_var
							value = 0
						}
					}
					check_variable = {
						which = brs_template_var
						value = 2
					}
				}
			}
			country_event = { id = brs.101 }
		}

		# make sure stat target is inside boundaries
		if = {
			limit = {
				OR = {
					NOT = {
						check_variable = {
							which = brs_target_var
							value = 0
						}
					}
					check_variable = {
						which = brs_target_var
						value = 17
					}
				}
			}
			country_event = { id = brs.100 }
		}
	}
}

# back to front to improve check speed
# Arguments:
# m = <0|1|...>
brs_set_template = {
	if = {
		limit = { brs_has_any_template = yes }
		brs_clr_template = yes
	}
	custom_tooltip = brs_set_template_$m$_tt
	hidden_effect = { set_variable = { which = brs_template_var value = $m$ } }
	# EDIT: Templates

	if = { limit = { brs_check_template = { a=1 } } brs_set_target2 = { a=9 } } # anbennar expanded
	else_if = { limit = { brs_check_template = { a=0 } } brs_set_target2 = { a=6 } } # vanilla
	hidden_effect = { set_country_flag = brs_template_used }
}
brs_clr_template = {
	custom_tooltip = brs_clr_template_tt
	hidden_effect = {
		clr_country_flag = brs_template_used
		set_variable = { which = brs_template_var value = 0 }
	}
}

# sets the ruler stat target to the input value (MUST BE AN INTEGER)
# Arguments:
# a = <0|1|2|3|4|...|14|15>
brs_set_target = {
	custom_tooltip = brs_set_target_$a$_tt
	hidden_effect = {
		set_country_flag = brs_setup_done
		brs_clr_template = yes
		set_variable = {
			which = brs_target_var
			value = $a$
		}
	}
}
# for set templates, does not clear variable
brs_set_target2 = {
	custom_tooltip = brs_set_target_$a$_tt
	hidden_effect = {
		set_country_flag = brs_setup_done
		set_variable = {
			which = brs_target_var
			value = $a$
		}
	}
}

# why are there two?
# When the game parses an empty argument (no argument) in a trigger, if it is the first character of a value, the game will throw an error and ignore the command!

# brs_update_ruler_add	= normal
# brs_update_ruler		= raise to minimum

# for this to work properly it would have to be a do_while loop. but paradox doesnt support that. fix: add 1 point to exported current ruler skill

# value = <adm|dip|mil>
brs_update_ruler = {
	while = {
		limit = {
			variable_arithmetic_trigger = {
				export_to_variable = {
					variable_name = ruler_skill
					value = $value$
				}
				change_variable = { which = ruler_skill value = 1 }
				check_variable = {
					which = brs_target_var
					which = ruler_skill
				}
			}
		}
		change_$value$ = 1
	}
}
# value = <adm|dip|mil>
brs_update_ruler_add = {
	if = { # skips many monthly iterations
		limit = { brs_check_ruler = { value = $value$ } }
		set_variable = { which = temp value = 1 }
		while = {
			limit = {
				check_variable = {
					which = brs_target_var
					which = temp
				}
			}
			change_$value$ = 1
			change_variable = { which = temp value = 1 }
		}
	}
}


brs_update_heir = {
	while = {
		limit = {
			variable_arithmetic_trigger = {
				export_to_variable = {
					variable_name = ruler_skill
					value = heir_$value$
				}
				change_variable = { which = ruler_skill value = 1 }
				check_variable = {
					which = brs_target_var
					which = ruler_skill
				}
			}
		}
		change_heir_$value$ = 1
	}
}
brs_update_heir_add = {
	if = { # skips many monthly iterations
		limit = { brs_check_heir = { value = $value$ } }
		set_variable = { which = temp value = 1 }
		while = {
			limit = {
				check_variable = {
					which = brs_target_var
					which = temp
				}
			}
			change_heir_$value$ = 1
			change_variable = { which = temp value = 1 }
		}
	}
}


# change_consort_value sets the value to the input, instead of adding input to ruler
brs_update_consort = {
	if = {
		limit = { brs_check_consort = { value = $value$ } }
		set_variable = {
			which = ruler_skill
			which = brs_target_var
		}
		brs_consort_helper = { value = $value$ }
	}
}
brs_update_consort_add = {
	export_to_variable = {
		which = ruler_skill
		value = consort_$value$
	}
	if = {
		limit = { check_variable = { which = brs_target_var which = ruler_skill } }
		change_variable = { which = ruler_skill which = brs_target_var }
		brs_consort_helper = { value = $value$ }
	}
}

# change_consort_x sets the skill to $value$, unlike change_x which adds $value$ to current skill
# back to front because check_variable does a greater than or equal to
brs_consort_helper = {
	if = { limit = { check_variable = { which = ruler_skill value = 16 } } change_consort_$value$ = 16 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 15 } } change_consort_$value$ = 15 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 14 } } change_consort_$value$ = 14 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 13 } } change_consort_$value$ = 13 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 12 } } change_consort_$value$ = 12 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 11 } } change_consort_$value$ = 11 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 10 } } change_consort_$value$ = 10 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 9 } } change_consort_$value$ = 9 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 8 } } change_consort_$value$ = 8 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 7 } } change_consort_$value$ = 7 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 6 } } change_consort_$value$ = 6 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 5 } } change_consort_$value$ = 5 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 4 } } change_consort_$value$ = 4 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 3 } } change_consort_$value$ = 3 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 2 } } change_consort_$value$ = 2 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 1 } } change_consort_$value$ = 1 }
	else_if = { limit = { check_variable = { which = ruler_skill value = 0 } } change_consort_$value$ = 0 }
}